{"message":"cannot borrow `competing` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":906,"byte_end":908,"line_start":32,"line_end":32,"column_start":36,"column_end":38,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":36,"highlight_end":38}],"label":"`competing` was mutably borrowed here in the previous iteration of the loop","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1570,"byte_end":1579,"line_start":48,"line_end":48,"column_start":21,"column_end":30,"is_primary":false,"text":[{"text":"                    competing[node][id] = 1;","highlight_start":21,"highlight_end":30}],"label":"borrows occur due to use of `competing` in closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":892,"byte_end":2910,"line_start":32,"line_end":77,"column_start":22,"column_end":11,"is_primary":false,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":22,"highlight_end":40},{"text":"            // Begin downpass through the tournament tree","highlight_start":1,"highlight_end":58},{"text":"            // Initialize variables local to each threads","highlight_start":1,"highlight_end":58},{"text":"            let idThread = i;","highlight_start":1,"highlight_end":30},{"text":"            let mut node = idThread + n;","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Begin local tournaments in each node","highlight_start":1,"highlight_end":52},{"text":"            // When thread reaches node == 1, may enter critical section","highlight_start":1,"highlight_end":73},{"text":"            unsafe {","highlight_start":1,"highlight_end":21},{"text":"                while node > 1 {","highlight_start":1,"highlight_end":33},{"text":"                    // Identify if thread came from left parent node (1) or right parent node (0)","highlight_start":1,"highlight_end":98},{"text":"                    // Get node number from id","highlight_start":1,"highlight_end":47},{"text":"                    let id = node % 2;","highlight_start":1,"highlight_end":39},{"text":"                    node = node / 2;","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Announce you are competing","highlight_start":1,"highlight_end":50},{"text":"                    competing[node][id] = 1;","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Local variable of if another thread is in same node","highlight_start":1,"highlight_end":75},{"text":"                    let local = (turn[node][1 - id] + id) % 2;","highlight_start":1,"highlight_end":63},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    turn[node][id] = local;","highlight_start":1,"highlight_end":44},{"text":"                    // Cond1 : You are the only thread, and no others are competing in same node","highlight_start":1,"highlight_end":97},{"text":"                    // Cond2 : The other thread is competing, but is outside the critical section","highlight_start":1,"highlight_end":98},{"text":"                    // while not true, wait until you can enter the critical section","highlight_start":1,"highlight_end":85},{"text":"                    while !((competing[node][1 - id] == 0)","highlight_start":1,"highlight_end":59},{"text":"                        || (local != (turn[node][1 - id] + id) % 2))","highlight_start":1,"highlight_end":69},{"text":"                    {}","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    edge[node] = id;","highlight_start":1,"highlight_end":37},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                // Critical section","highlight_start":1,"highlight_end":36},{"text":"                // update global sum","highlight_start":1,"highlight_end":37},{"text":"                totalsum += work(4);","highlight_start":1,"highlight_end":37},{"text":"                // update node so as to stay out of next iteration of big while loop","highlight_start":1,"highlight_end":85},{"text":"                node = 1;","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Begin UP pass through the tournament tree","highlight_start":1,"highlight_end":61},{"text":"                // set flags of other nodes you competed with to false (0) so they may compete as well","highlight_start":1,"highlight_end":103},{"text":"                // propagate values through the arithmetic to climb up the tree","highlight_start":1,"highlight_end":80},{"text":"                while node < n {","highlight_start":1,"highlight_end":33},{"text":"                    competing[node][edge[node]] = 0;","highlight_start":1,"highlight_end":53},{"text":"                    node = 2 * node + edge[node];","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }));","highlight_start":1,"highlight_end":11}],"label":"argument requires that `competing` is borrowed for `'static`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0499]\u001b[0m\u001b[0m\u001b[1m: cannot borrow `competing` as mutable more than once at a time\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:32:36\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m        threads.push(thread::spawn(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`competing` was mutably borrowed here in the previous iteration of the loop\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m______________________|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Begin downpass through the tournament tree\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Initialize variables local to each threads\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let idThread = i;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m48\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    competing[node][id] = 1;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mborrows occur due to use of `competing` in closure\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m77\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|__________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12margument requires that `competing` is borrowed for `'static`\u001b[0m\n\n"}
{"message":"cannot borrow `turn` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":906,"byte_end":908,"line_start":32,"line_end":32,"column_start":36,"column_end":38,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":36,"highlight_end":38}],"label":"`turn` was mutably borrowed here in the previous iteration of the loop","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1704,"byte_end":1708,"line_start":51,"line_end":51,"column_start":34,"column_end":38,"is_primary":false,"text":[{"text":"                    let local = (turn[node][1 - id] + id) % 2;","highlight_start":34,"highlight_end":38}],"label":"borrows occur due to use of `turn` in closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":892,"byte_end":2910,"line_start":32,"line_end":77,"column_start":22,"column_end":11,"is_primary":false,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":22,"highlight_end":40},{"text":"            // Begin downpass through the tournament tree","highlight_start":1,"highlight_end":58},{"text":"            // Initialize variables local to each threads","highlight_start":1,"highlight_end":58},{"text":"            let idThread = i;","highlight_start":1,"highlight_end":30},{"text":"            let mut node = idThread + n;","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Begin local tournaments in each node","highlight_start":1,"highlight_end":52},{"text":"            // When thread reaches node == 1, may enter critical section","highlight_start":1,"highlight_end":73},{"text":"            unsafe {","highlight_start":1,"highlight_end":21},{"text":"                while node > 1 {","highlight_start":1,"highlight_end":33},{"text":"                    // Identify if thread came from left parent node (1) or right parent node (0)","highlight_start":1,"highlight_end":98},{"text":"                    // Get node number from id","highlight_start":1,"highlight_end":47},{"text":"                    let id = node % 2;","highlight_start":1,"highlight_end":39},{"text":"                    node = node / 2;","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Announce you are competing","highlight_start":1,"highlight_end":50},{"text":"                    competing[node][id] = 1;","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Local variable of if another thread is in same node","highlight_start":1,"highlight_end":75},{"text":"                    let local = (turn[node][1 - id] + id) % 2;","highlight_start":1,"highlight_end":63},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    turn[node][id] = local;","highlight_start":1,"highlight_end":44},{"text":"                    // Cond1 : You are the only thread, and no others are competing in same node","highlight_start":1,"highlight_end":97},{"text":"                    // Cond2 : The other thread is competing, but is outside the critical section","highlight_start":1,"highlight_end":98},{"text":"                    // while not true, wait until you can enter the critical section","highlight_start":1,"highlight_end":85},{"text":"                    while !((competing[node][1 - id] == 0)","highlight_start":1,"highlight_end":59},{"text":"                        || (local != (turn[node][1 - id] + id) % 2))","highlight_start":1,"highlight_end":69},{"text":"                    {}","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    edge[node] = id;","highlight_start":1,"highlight_end":37},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                // Critical section","highlight_start":1,"highlight_end":36},{"text":"                // update global sum","highlight_start":1,"highlight_end":37},{"text":"                totalsum += work(4);","highlight_start":1,"highlight_end":37},{"text":"                // update node so as to stay out of next iteration of big while loop","highlight_start":1,"highlight_end":85},{"text":"                node = 1;","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Begin UP pass through the tournament tree","highlight_start":1,"highlight_end":61},{"text":"                // set flags of other nodes you competed with to false (0) so they may compete as well","highlight_start":1,"highlight_end":103},{"text":"                // propagate values through the arithmetic to climb up the tree","highlight_start":1,"highlight_end":80},{"text":"                while node < n {","highlight_start":1,"highlight_end":33},{"text":"                    competing[node][edge[node]] = 0;","highlight_start":1,"highlight_end":53},{"text":"                    node = 2 * node + edge[node];","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }));","highlight_start":1,"highlight_end":11}],"label":"argument requires that `turn` is borrowed for `'static`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0499]\u001b[0m\u001b[0m\u001b[1m: cannot borrow `turn` as mutable more than once at a time\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:32:36\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m        threads.push(thread::spawn(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`turn` was mutably borrowed here in the previous iteration of the loop\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m______________________|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Begin downpass through the tournament tree\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Initialize variables local to each threads\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let idThread = i;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m51\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    let local = (turn[node][1 - id] + id) % 2;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mborrows occur due to use of `turn` in closure\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m77\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|__________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12margument requires that `turn` is borrowed for `'static`\u001b[0m\n\n"}
{"message":"cannot borrow `edge` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":906,"byte_end":908,"line_start":32,"line_end":32,"column_start":36,"column_end":38,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":36,"highlight_end":38}],"label":"`edge` was mutably borrowed here in the previous iteration of the loop","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":2231,"byte_end":2235,"line_start":61,"line_end":61,"column_start":21,"column_end":25,"is_primary":false,"text":[{"text":"                    edge[node] = id;","highlight_start":21,"highlight_end":25}],"label":"borrows occur due to use of `edge` in closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":892,"byte_end":2910,"line_start":32,"line_end":77,"column_start":22,"column_end":11,"is_primary":false,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":22,"highlight_end":40},{"text":"            // Begin downpass through the tournament tree","highlight_start":1,"highlight_end":58},{"text":"            // Initialize variables local to each threads","highlight_start":1,"highlight_end":58},{"text":"            let idThread = i;","highlight_start":1,"highlight_end":30},{"text":"            let mut node = idThread + n;","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Begin local tournaments in each node","highlight_start":1,"highlight_end":52},{"text":"            // When thread reaches node == 1, may enter critical section","highlight_start":1,"highlight_end":73},{"text":"            unsafe {","highlight_start":1,"highlight_end":21},{"text":"                while node > 1 {","highlight_start":1,"highlight_end":33},{"text":"                    // Identify if thread came from left parent node (1) or right parent node (0)","highlight_start":1,"highlight_end":98},{"text":"                    // Get node number from id","highlight_start":1,"highlight_end":47},{"text":"                    let id = node % 2;","highlight_start":1,"highlight_end":39},{"text":"                    node = node / 2;","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Announce you are competing","highlight_start":1,"highlight_end":50},{"text":"                    competing[node][id] = 1;","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Local variable of if another thread is in same node","highlight_start":1,"highlight_end":75},{"text":"                    let local = (turn[node][1 - id] + id) % 2;","highlight_start":1,"highlight_end":63},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    turn[node][id] = local;","highlight_start":1,"highlight_end":44},{"text":"                    // Cond1 : You are the only thread, and no others are competing in same node","highlight_start":1,"highlight_end":97},{"text":"                    // Cond2 : The other thread is competing, but is outside the critical section","highlight_start":1,"highlight_end":98},{"text":"                    // while not true, wait until you can enter the critical section","highlight_start":1,"highlight_end":85},{"text":"                    while !((competing[node][1 - id] == 0)","highlight_start":1,"highlight_end":59},{"text":"                        || (local != (turn[node][1 - id] + id) % 2))","highlight_start":1,"highlight_end":69},{"text":"                    {}","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    edge[node] = id;","highlight_start":1,"highlight_end":37},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                // Critical section","highlight_start":1,"highlight_end":36},{"text":"                // update global sum","highlight_start":1,"highlight_end":37},{"text":"                totalsum += work(4);","highlight_start":1,"highlight_end":37},{"text":"                // update node so as to stay out of next iteration of big while loop","highlight_start":1,"highlight_end":85},{"text":"                node = 1;","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Begin UP pass through the tournament tree","highlight_start":1,"highlight_end":61},{"text":"                // set flags of other nodes you competed with to false (0) so they may compete as well","highlight_start":1,"highlight_end":103},{"text":"                // propagate values through the arithmetic to climb up the tree","highlight_start":1,"highlight_end":80},{"text":"                while node < n {","highlight_start":1,"highlight_end":33},{"text":"                    competing[node][edge[node]] = 0;","highlight_start":1,"highlight_end":53},{"text":"                    node = 2 * node + edge[node];","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }));","highlight_start":1,"highlight_end":11}],"label":"argument requires that `edge` is borrowed for `'static`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0499]\u001b[0m\u001b[0m\u001b[1m: cannot borrow `edge` as mutable more than once at a time\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:32:36\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m        threads.push(thread::spawn(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`edge` was mutably borrowed here in the previous iteration of the loop\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m______________________|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Begin downpass through the tournament tree\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Initialize variables local to each threads\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let idThread = i;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    edge[node] = id;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mborrows occur due to use of `edge` in closure\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m77\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|__________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12margument requires that `edge` is borrowed for `'static`\u001b[0m\n\n"}
{"message":"cannot borrow `totalsum` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":906,"byte_end":908,"line_start":32,"line_end":32,"column_start":36,"column_end":38,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":36,"highlight_end":38}],"label":"`totalsum` was mutably borrowed here in the previous iteration of the loop","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":2355,"byte_end":2363,"line_start":65,"line_end":65,"column_start":17,"column_end":25,"is_primary":false,"text":[{"text":"                totalsum += work(4);","highlight_start":17,"highlight_end":25}],"label":"borrows occur due to use of `totalsum` in closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":892,"byte_end":2910,"line_start":32,"line_end":77,"column_start":22,"column_end":11,"is_primary":false,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":22,"highlight_end":40},{"text":"            // Begin downpass through the tournament tree","highlight_start":1,"highlight_end":58},{"text":"            // Initialize variables local to each threads","highlight_start":1,"highlight_end":58},{"text":"            let idThread = i;","highlight_start":1,"highlight_end":30},{"text":"            let mut node = idThread + n;","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Begin local tournaments in each node","highlight_start":1,"highlight_end":52},{"text":"            // When thread reaches node == 1, may enter critical section","highlight_start":1,"highlight_end":73},{"text":"            unsafe {","highlight_start":1,"highlight_end":21},{"text":"                while node > 1 {","highlight_start":1,"highlight_end":33},{"text":"                    // Identify if thread came from left parent node (1) or right parent node (0)","highlight_start":1,"highlight_end":98},{"text":"                    // Get node number from id","highlight_start":1,"highlight_end":47},{"text":"                    let id = node % 2;","highlight_start":1,"highlight_end":39},{"text":"                    node = node / 2;","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Announce you are competing","highlight_start":1,"highlight_end":50},{"text":"                    competing[node][id] = 1;","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Local variable of if another thread is in same node","highlight_start":1,"highlight_end":75},{"text":"                    let local = (turn[node][1 - id] + id) % 2;","highlight_start":1,"highlight_end":63},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    turn[node][id] = local;","highlight_start":1,"highlight_end":44},{"text":"                    // Cond1 : You are the only thread, and no others are competing in same node","highlight_start":1,"highlight_end":97},{"text":"                    // Cond2 : The other thread is competing, but is outside the critical section","highlight_start":1,"highlight_end":98},{"text":"                    // while not true, wait until you can enter the critical section","highlight_start":1,"highlight_end":85},{"text":"                    while !((competing[node][1 - id] == 0)","highlight_start":1,"highlight_end":59},{"text":"                        || (local != (turn[node][1 - id] + id) % 2))","highlight_start":1,"highlight_end":69},{"text":"                    {}","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    edge[node] = id;","highlight_start":1,"highlight_end":37},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                // Critical section","highlight_start":1,"highlight_end":36},{"text":"                // update global sum","highlight_start":1,"highlight_end":37},{"text":"                totalsum += work(4);","highlight_start":1,"highlight_end":37},{"text":"                // update node so as to stay out of next iteration of big while loop","highlight_start":1,"highlight_end":85},{"text":"                node = 1;","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Begin UP pass through the tournament tree","highlight_start":1,"highlight_end":61},{"text":"                // set flags of other nodes you competed with to false (0) so they may compete as well","highlight_start":1,"highlight_end":103},{"text":"                // propagate values through the arithmetic to climb up the tree","highlight_start":1,"highlight_end":80},{"text":"                while node < n {","highlight_start":1,"highlight_end":33},{"text":"                    competing[node][edge[node]] = 0;","highlight_start":1,"highlight_end":53},{"text":"                    node = 2 * node + edge[node];","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }));","highlight_start":1,"highlight_end":11}],"label":"argument requires that `totalsum` is borrowed for `'static`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0499]\u001b[0m\u001b[0m\u001b[1m: cannot borrow `totalsum` as mutable more than once at a time\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:32:36\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m        threads.push(thread::spawn(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`totalsum` was mutably borrowed here in the previous iteration of the loop\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m______________________|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Begin downpass through the tournament tree\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Initialize variables local to each threads\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let idThread = i;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m65\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                totalsum += work(4);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mborrows occur due to use of `totalsum` in closure\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m77\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|__________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12margument requires that `totalsum` is borrowed for `'static`\u001b[0m\n\n"}
{"message":"closure may outlive the current function, but it borrows `i`, which is owned by the current function","code":{"code":"E0373","explanation":"A captured variable in a closure may not live long enough.\n\nErroneous code example:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure as shown in the previous code example.\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behavior is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1054,"byte_end":1055,"line_start":35,"line_end":35,"column_start":28,"column_end":29,"is_primary":false,"text":[{"text":"            let idThread = i;","highlight_start":28,"highlight_end":29}],"label":"`i` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":906,"byte_end":908,"line_start":32,"line_end":32,"column_start":36,"column_end":38,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":36,"highlight_end":38}],"label":"may outlive borrowed value `i`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function requires argument type to outlive `'static`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":892,"byte_end":2910,"line_start":32,"line_end":77,"column_start":22,"column_end":11,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":22,"highlight_end":40},{"text":"            // Begin downpass through the tournament tree","highlight_start":1,"highlight_end":58},{"text":"            // Initialize variables local to each threads","highlight_start":1,"highlight_end":58},{"text":"            let idThread = i;","highlight_start":1,"highlight_end":30},{"text":"            let mut node = idThread + n;","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Begin local tournaments in each node","highlight_start":1,"highlight_end":52},{"text":"            // When thread reaches node == 1, may enter critical section","highlight_start":1,"highlight_end":73},{"text":"            unsafe {","highlight_start":1,"highlight_end":21},{"text":"                while node > 1 {","highlight_start":1,"highlight_end":33},{"text":"                    // Identify if thread came from left parent node (1) or right parent node (0)","highlight_start":1,"highlight_end":98},{"text":"                    // Get node number from id","highlight_start":1,"highlight_end":47},{"text":"                    let id = node % 2;","highlight_start":1,"highlight_end":39},{"text":"                    node = node / 2;","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Announce you are competing","highlight_start":1,"highlight_end":50},{"text":"                    competing[node][id] = 1;","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Local variable of if another thread is in same node","highlight_start":1,"highlight_end":75},{"text":"                    let local = (turn[node][1 - id] + id) % 2;","highlight_start":1,"highlight_end":63},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    turn[node][id] = local;","highlight_start":1,"highlight_end":44},{"text":"                    // Cond1 : You are the only thread, and no others are competing in same node","highlight_start":1,"highlight_end":97},{"text":"                    // Cond2 : The other thread is competing, but is outside the critical section","highlight_start":1,"highlight_end":98},{"text":"                    // while not true, wait until you can enter the critical section","highlight_start":1,"highlight_end":85},{"text":"                    while !((competing[node][1 - id] == 0)","highlight_start":1,"highlight_end":59},{"text":"                        || (local != (turn[node][1 - id] + id) % 2))","highlight_start":1,"highlight_end":69},{"text":"                    {}","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    edge[node] = id;","highlight_start":1,"highlight_end":37},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                // Critical section","highlight_start":1,"highlight_end":36},{"text":"                // update global sum","highlight_start":1,"highlight_end":37},{"text":"                totalsum += work(4);","highlight_start":1,"highlight_end":37},{"text":"                // update node so as to stay out of next iteration of big while loop","highlight_start":1,"highlight_end":85},{"text":"                node = 1;","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Begin UP pass through the tournament tree","highlight_start":1,"highlight_end":61},{"text":"                // set flags of other nodes you competed with to false (0) so they may compete as well","highlight_start":1,"highlight_end":103},{"text":"                // propagate values through the arithmetic to climb up the tree","highlight_start":1,"highlight_end":80},{"text":"                while node < n {","highlight_start":1,"highlight_end":33},{"text":"                    competing[node][edge[node]] = 0;","highlight_start":1,"highlight_end":53},{"text":"                    node = 2 * node + edge[node];","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }));","highlight_start":1,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"to force the closure to take ownership of `i` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":906,"byte_end":908,"line_start":32,"line_end":32,"column_start":36,"column_end":38,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":36,"highlight_end":38}],"label":null,"suggested_replacement":"move ||","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0373]\u001b[0m\u001b[0m\u001b[1m: closure may outlive the current function, but it borrows `i`, which is owned by the current function\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:32:36\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        threads.push(thread::spawn(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmay outlive borrowed value `i`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let idThread = i;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`i` is borrowed here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function requires argument type to outlive `'static`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:32:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m        threads.push(thread::spawn(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m______________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Begin downpass through the tournament tree\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Initialize variables local to each threads\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let idThread = i;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m77\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|__________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: to force the closure to take ownership of `i` (and any other referenced variables), use the `move` keyword\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        threads.push(thread::spawn(move || {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^\u001b[0m\n\n"}
{"message":"closure may outlive the current function, but it borrows `turn`, which is owned by the current function","code":{"code":"E0373","explanation":"A captured variable in a closure may not live long enough.\n\nErroneous code example:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure as shown in the previous code example.\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behavior is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1704,"byte_end":1708,"line_start":51,"line_end":51,"column_start":34,"column_end":38,"is_primary":false,"text":[{"text":"                    let local = (turn[node][1 - id] + id) % 2;","highlight_start":34,"highlight_end":38}],"label":"`turn` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":906,"byte_end":908,"line_start":32,"line_end":32,"column_start":36,"column_end":38,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":36,"highlight_end":38}],"label":"may outlive borrowed value `turn`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function requires argument type to outlive `'static`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":892,"byte_end":2910,"line_start":32,"line_end":77,"column_start":22,"column_end":11,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":22,"highlight_end":40},{"text":"            // Begin downpass through the tournament tree","highlight_start":1,"highlight_end":58},{"text":"            // Initialize variables local to each threads","highlight_start":1,"highlight_end":58},{"text":"            let idThread = i;","highlight_start":1,"highlight_end":30},{"text":"            let mut node = idThread + n;","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Begin local tournaments in each node","highlight_start":1,"highlight_end":52},{"text":"            // When thread reaches node == 1, may enter critical section","highlight_start":1,"highlight_end":73},{"text":"            unsafe {","highlight_start":1,"highlight_end":21},{"text":"                while node > 1 {","highlight_start":1,"highlight_end":33},{"text":"                    // Identify if thread came from left parent node (1) or right parent node (0)","highlight_start":1,"highlight_end":98},{"text":"                    // Get node number from id","highlight_start":1,"highlight_end":47},{"text":"                    let id = node % 2;","highlight_start":1,"highlight_end":39},{"text":"                    node = node / 2;","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Announce you are competing","highlight_start":1,"highlight_end":50},{"text":"                    competing[node][id] = 1;","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Local variable of if another thread is in same node","highlight_start":1,"highlight_end":75},{"text":"                    let local = (turn[node][1 - id] + id) % 2;","highlight_start":1,"highlight_end":63},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    turn[node][id] = local;","highlight_start":1,"highlight_end":44},{"text":"                    // Cond1 : You are the only thread, and no others are competing in same node","highlight_start":1,"highlight_end":97},{"text":"                    // Cond2 : The other thread is competing, but is outside the critical section","highlight_start":1,"highlight_end":98},{"text":"                    // while not true, wait until you can enter the critical section","highlight_start":1,"highlight_end":85},{"text":"                    while !((competing[node][1 - id] == 0)","highlight_start":1,"highlight_end":59},{"text":"                        || (local != (turn[node][1 - id] + id) % 2))","highlight_start":1,"highlight_end":69},{"text":"                    {}","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    edge[node] = id;","highlight_start":1,"highlight_end":37},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                // Critical section","highlight_start":1,"highlight_end":36},{"text":"                // update global sum","highlight_start":1,"highlight_end":37},{"text":"                totalsum += work(4);","highlight_start":1,"highlight_end":37},{"text":"                // update node so as to stay out of next iteration of big while loop","highlight_start":1,"highlight_end":85},{"text":"                node = 1;","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Begin UP pass through the tournament tree","highlight_start":1,"highlight_end":61},{"text":"                // set flags of other nodes you competed with to false (0) so they may compete as well","highlight_start":1,"highlight_end":103},{"text":"                // propagate values through the arithmetic to climb up the tree","highlight_start":1,"highlight_end":80},{"text":"                while node < n {","highlight_start":1,"highlight_end":33},{"text":"                    competing[node][edge[node]] = 0;","highlight_start":1,"highlight_end":53},{"text":"                    node = 2 * node + edge[node];","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }));","highlight_start":1,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"to force the closure to take ownership of `turn` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":906,"byte_end":908,"line_start":32,"line_end":32,"column_start":36,"column_end":38,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":36,"highlight_end":38}],"label":null,"suggested_replacement":"move ||","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0373]\u001b[0m\u001b[0m\u001b[1m: closure may outlive the current function, but it borrows `turn`, which is owned by the current function\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:32:36\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        threads.push(thread::spawn(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmay outlive borrowed value `turn`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m51\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    let local = (turn[node][1 - id] + id) % 2;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`turn` is borrowed here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function requires argument type to outlive `'static`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:32:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m        threads.push(thread::spawn(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m______________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Begin downpass through the tournament tree\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Initialize variables local to each threads\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let idThread = i;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m77\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|__________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: to force the closure to take ownership of `turn` (and any other referenced variables), use the `move` keyword\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        threads.push(thread::spawn(move || {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^\u001b[0m\n\n"}
{"message":"closure may outlive the current function, but it borrows `competing`, which is owned by the current function","code":{"code":"E0373","explanation":"A captured variable in a closure may not live long enough.\n\nErroneous code example:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure as shown in the previous code example.\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behavior is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1570,"byte_end":1579,"line_start":48,"line_end":48,"column_start":21,"column_end":30,"is_primary":false,"text":[{"text":"                    competing[node][id] = 1;","highlight_start":21,"highlight_end":30}],"label":"`competing` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":906,"byte_end":908,"line_start":32,"line_end":32,"column_start":36,"column_end":38,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":36,"highlight_end":38}],"label":"may outlive borrowed value `competing`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function requires argument type to outlive `'static`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":892,"byte_end":2910,"line_start":32,"line_end":77,"column_start":22,"column_end":11,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":22,"highlight_end":40},{"text":"            // Begin downpass through the tournament tree","highlight_start":1,"highlight_end":58},{"text":"            // Initialize variables local to each threads","highlight_start":1,"highlight_end":58},{"text":"            let idThread = i;","highlight_start":1,"highlight_end":30},{"text":"            let mut node = idThread + n;","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Begin local tournaments in each node","highlight_start":1,"highlight_end":52},{"text":"            // When thread reaches node == 1, may enter critical section","highlight_start":1,"highlight_end":73},{"text":"            unsafe {","highlight_start":1,"highlight_end":21},{"text":"                while node > 1 {","highlight_start":1,"highlight_end":33},{"text":"                    // Identify if thread came from left parent node (1) or right parent node (0)","highlight_start":1,"highlight_end":98},{"text":"                    // Get node number from id","highlight_start":1,"highlight_end":47},{"text":"                    let id = node % 2;","highlight_start":1,"highlight_end":39},{"text":"                    node = node / 2;","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Announce you are competing","highlight_start":1,"highlight_end":50},{"text":"                    competing[node][id] = 1;","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Local variable of if another thread is in same node","highlight_start":1,"highlight_end":75},{"text":"                    let local = (turn[node][1 - id] + id) % 2;","highlight_start":1,"highlight_end":63},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    turn[node][id] = local;","highlight_start":1,"highlight_end":44},{"text":"                    // Cond1 : You are the only thread, and no others are competing in same node","highlight_start":1,"highlight_end":97},{"text":"                    // Cond2 : The other thread is competing, but is outside the critical section","highlight_start":1,"highlight_end":98},{"text":"                    // while not true, wait until you can enter the critical section","highlight_start":1,"highlight_end":85},{"text":"                    while !((competing[node][1 - id] == 0)","highlight_start":1,"highlight_end":59},{"text":"                        || (local != (turn[node][1 - id] + id) % 2))","highlight_start":1,"highlight_end":69},{"text":"                    {}","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    edge[node] = id;","highlight_start":1,"highlight_end":37},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                // Critical section","highlight_start":1,"highlight_end":36},{"text":"                // update global sum","highlight_start":1,"highlight_end":37},{"text":"                totalsum += work(4);","highlight_start":1,"highlight_end":37},{"text":"                // update node so as to stay out of next iteration of big while loop","highlight_start":1,"highlight_end":85},{"text":"                node = 1;","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Begin UP pass through the tournament tree","highlight_start":1,"highlight_end":61},{"text":"                // set flags of other nodes you competed with to false (0) so they may compete as well","highlight_start":1,"highlight_end":103},{"text":"                // propagate values through the arithmetic to climb up the tree","highlight_start":1,"highlight_end":80},{"text":"                while node < n {","highlight_start":1,"highlight_end":33},{"text":"                    competing[node][edge[node]] = 0;","highlight_start":1,"highlight_end":53},{"text":"                    node = 2 * node + edge[node];","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }));","highlight_start":1,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"to force the closure to take ownership of `competing` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":906,"byte_end":908,"line_start":32,"line_end":32,"column_start":36,"column_end":38,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":36,"highlight_end":38}],"label":null,"suggested_replacement":"move ||","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0373]\u001b[0m\u001b[0m\u001b[1m: closure may outlive the current function, but it borrows `competing`, which is owned by the current function\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:32:36\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        threads.push(thread::spawn(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmay outlive borrowed value `competing`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m48\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    competing[node][id] = 1;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`competing` is borrowed here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function requires argument type to outlive `'static`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:32:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m        threads.push(thread::spawn(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m______________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Begin downpass through the tournament tree\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Initialize variables local to each threads\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let idThread = i;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m77\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|__________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: to force the closure to take ownership of `competing` (and any other referenced variables), use the `move` keyword\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        threads.push(thread::spawn(move || {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^\u001b[0m\n\n"}
{"message":"closure may outlive the current function, but it borrows `edge`, which is owned by the current function","code":{"code":"E0373","explanation":"A captured variable in a closure may not live long enough.\n\nErroneous code example:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure as shown in the previous code example.\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behavior is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":2231,"byte_end":2235,"line_start":61,"line_end":61,"column_start":21,"column_end":25,"is_primary":false,"text":[{"text":"                    edge[node] = id;","highlight_start":21,"highlight_end":25}],"label":"`edge` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":906,"byte_end":908,"line_start":32,"line_end":32,"column_start":36,"column_end":38,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":36,"highlight_end":38}],"label":"may outlive borrowed value `edge`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function requires argument type to outlive `'static`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":892,"byte_end":2910,"line_start":32,"line_end":77,"column_start":22,"column_end":11,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":22,"highlight_end":40},{"text":"            // Begin downpass through the tournament tree","highlight_start":1,"highlight_end":58},{"text":"            // Initialize variables local to each threads","highlight_start":1,"highlight_end":58},{"text":"            let idThread = i;","highlight_start":1,"highlight_end":30},{"text":"            let mut node = idThread + n;","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Begin local tournaments in each node","highlight_start":1,"highlight_end":52},{"text":"            // When thread reaches node == 1, may enter critical section","highlight_start":1,"highlight_end":73},{"text":"            unsafe {","highlight_start":1,"highlight_end":21},{"text":"                while node > 1 {","highlight_start":1,"highlight_end":33},{"text":"                    // Identify if thread came from left parent node (1) or right parent node (0)","highlight_start":1,"highlight_end":98},{"text":"                    // Get node number from id","highlight_start":1,"highlight_end":47},{"text":"                    let id = node % 2;","highlight_start":1,"highlight_end":39},{"text":"                    node = node / 2;","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Announce you are competing","highlight_start":1,"highlight_end":50},{"text":"                    competing[node][id] = 1;","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Local variable of if another thread is in same node","highlight_start":1,"highlight_end":75},{"text":"                    let local = (turn[node][1 - id] + id) % 2;","highlight_start":1,"highlight_end":63},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    turn[node][id] = local;","highlight_start":1,"highlight_end":44},{"text":"                    // Cond1 : You are the only thread, and no others are competing in same node","highlight_start":1,"highlight_end":97},{"text":"                    // Cond2 : The other thread is competing, but is outside the critical section","highlight_start":1,"highlight_end":98},{"text":"                    // while not true, wait until you can enter the critical section","highlight_start":1,"highlight_end":85},{"text":"                    while !((competing[node][1 - id] == 0)","highlight_start":1,"highlight_end":59},{"text":"                        || (local != (turn[node][1 - id] + id) % 2))","highlight_start":1,"highlight_end":69},{"text":"                    {}","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    edge[node] = id;","highlight_start":1,"highlight_end":37},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                // Critical section","highlight_start":1,"highlight_end":36},{"text":"                // update global sum","highlight_start":1,"highlight_end":37},{"text":"                totalsum += work(4);","highlight_start":1,"highlight_end":37},{"text":"                // update node so as to stay out of next iteration of big while loop","highlight_start":1,"highlight_end":85},{"text":"                node = 1;","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Begin UP pass through the tournament tree","highlight_start":1,"highlight_end":61},{"text":"                // set flags of other nodes you competed with to false (0) so they may compete as well","highlight_start":1,"highlight_end":103},{"text":"                // propagate values through the arithmetic to climb up the tree","highlight_start":1,"highlight_end":80},{"text":"                while node < n {","highlight_start":1,"highlight_end":33},{"text":"                    competing[node][edge[node]] = 0;","highlight_start":1,"highlight_end":53},{"text":"                    node = 2 * node + edge[node];","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }));","highlight_start":1,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"to force the closure to take ownership of `edge` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":906,"byte_end":908,"line_start":32,"line_end":32,"column_start":36,"column_end":38,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":36,"highlight_end":38}],"label":null,"suggested_replacement":"move ||","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0373]\u001b[0m\u001b[0m\u001b[1m: closure may outlive the current function, but it borrows `edge`, which is owned by the current function\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:32:36\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        threads.push(thread::spawn(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmay outlive borrowed value `edge`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    edge[node] = id;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`edge` is borrowed here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function requires argument type to outlive `'static`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:32:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m        threads.push(thread::spawn(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m______________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Begin downpass through the tournament tree\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Initialize variables local to each threads\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let idThread = i;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m77\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|__________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: to force the closure to take ownership of `edge` (and any other referenced variables), use the `move` keyword\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        threads.push(thread::spawn(move || {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^\u001b[0m\n\n"}
{"message":"closure may outlive the current function, but it borrows `n`, which is owned by the current function","code":{"code":"E0373","explanation":"A captured variable in a closure may not live long enough.\n\nErroneous code example:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure as shown in the previous code example.\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behavior is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1095,"byte_end":1096,"line_start":36,"line_end":36,"column_start":39,"column_end":40,"is_primary":false,"text":[{"text":"            let mut node = idThread + n;","highlight_start":39,"highlight_end":40}],"label":"`n` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":906,"byte_end":908,"line_start":32,"line_end":32,"column_start":36,"column_end":38,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":36,"highlight_end":38}],"label":"may outlive borrowed value `n`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function requires argument type to outlive `'static`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":892,"byte_end":2910,"line_start":32,"line_end":77,"column_start":22,"column_end":11,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":22,"highlight_end":40},{"text":"            // Begin downpass through the tournament tree","highlight_start":1,"highlight_end":58},{"text":"            // Initialize variables local to each threads","highlight_start":1,"highlight_end":58},{"text":"            let idThread = i;","highlight_start":1,"highlight_end":30},{"text":"            let mut node = idThread + n;","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Begin local tournaments in each node","highlight_start":1,"highlight_end":52},{"text":"            // When thread reaches node == 1, may enter critical section","highlight_start":1,"highlight_end":73},{"text":"            unsafe {","highlight_start":1,"highlight_end":21},{"text":"                while node > 1 {","highlight_start":1,"highlight_end":33},{"text":"                    // Identify if thread came from left parent node (1) or right parent node (0)","highlight_start":1,"highlight_end":98},{"text":"                    // Get node number from id","highlight_start":1,"highlight_end":47},{"text":"                    let id = node % 2;","highlight_start":1,"highlight_end":39},{"text":"                    node = node / 2;","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Announce you are competing","highlight_start":1,"highlight_end":50},{"text":"                    competing[node][id] = 1;","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Local variable of if another thread is in same node","highlight_start":1,"highlight_end":75},{"text":"                    let local = (turn[node][1 - id] + id) % 2;","highlight_start":1,"highlight_end":63},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    turn[node][id] = local;","highlight_start":1,"highlight_end":44},{"text":"                    // Cond1 : You are the only thread, and no others are competing in same node","highlight_start":1,"highlight_end":97},{"text":"                    // Cond2 : The other thread is competing, but is outside the critical section","highlight_start":1,"highlight_end":98},{"text":"                    // while not true, wait until you can enter the critical section","highlight_start":1,"highlight_end":85},{"text":"                    while !((competing[node][1 - id] == 0)","highlight_start":1,"highlight_end":59},{"text":"                        || (local != (turn[node][1 - id] + id) % 2))","highlight_start":1,"highlight_end":69},{"text":"                    {}","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    edge[node] = id;","highlight_start":1,"highlight_end":37},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                // Critical section","highlight_start":1,"highlight_end":36},{"text":"                // update global sum","highlight_start":1,"highlight_end":37},{"text":"                totalsum += work(4);","highlight_start":1,"highlight_end":37},{"text":"                // update node so as to stay out of next iteration of big while loop","highlight_start":1,"highlight_end":85},{"text":"                node = 1;","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Begin UP pass through the tournament tree","highlight_start":1,"highlight_end":61},{"text":"                // set flags of other nodes you competed with to false (0) so they may compete as well","highlight_start":1,"highlight_end":103},{"text":"                // propagate values through the arithmetic to climb up the tree","highlight_start":1,"highlight_end":80},{"text":"                while node < n {","highlight_start":1,"highlight_end":33},{"text":"                    competing[node][edge[node]] = 0;","highlight_start":1,"highlight_end":53},{"text":"                    node = 2 * node + edge[node];","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }));","highlight_start":1,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"to force the closure to take ownership of `n` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":906,"byte_end":908,"line_start":32,"line_end":32,"column_start":36,"column_end":38,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":36,"highlight_end":38}],"label":null,"suggested_replacement":"move ||","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0373]\u001b[0m\u001b[0m\u001b[1m: closure may outlive the current function, but it borrows `n`, which is owned by the current function\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:32:36\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        threads.push(thread::spawn(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmay outlive borrowed value `n`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m36\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let mut node = idThread + n;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`n` is borrowed here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function requires argument type to outlive `'static`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:32:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m        threads.push(thread::spawn(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m______________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Begin downpass through the tournament tree\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Initialize variables local to each threads\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let idThread = i;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m77\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|__________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: to force the closure to take ownership of `n` (and any other referenced variables), use the `move` keyword\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        threads.push(thread::spawn(move || {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^\u001b[0m\n\n"}
{"message":"closure may outlive the current function, but it borrows `totalsum`, which is owned by the current function","code":{"code":"E0373","explanation":"A captured variable in a closure may not live long enough.\n\nErroneous code example:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure as shown in the previous code example.\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behavior is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":2355,"byte_end":2363,"line_start":65,"line_end":65,"column_start":17,"column_end":25,"is_primary":false,"text":[{"text":"                totalsum += work(4);","highlight_start":17,"highlight_end":25}],"label":"`totalsum` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":906,"byte_end":908,"line_start":32,"line_end":32,"column_start":36,"column_end":38,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":36,"highlight_end":38}],"label":"may outlive borrowed value `totalsum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function requires argument type to outlive `'static`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":892,"byte_end":2910,"line_start":32,"line_end":77,"column_start":22,"column_end":11,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":22,"highlight_end":40},{"text":"            // Begin downpass through the tournament tree","highlight_start":1,"highlight_end":58},{"text":"            // Initialize variables local to each threads","highlight_start":1,"highlight_end":58},{"text":"            let idThread = i;","highlight_start":1,"highlight_end":30},{"text":"            let mut node = idThread + n;","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Begin local tournaments in each node","highlight_start":1,"highlight_end":52},{"text":"            // When thread reaches node == 1, may enter critical section","highlight_start":1,"highlight_end":73},{"text":"            unsafe {","highlight_start":1,"highlight_end":21},{"text":"                while node > 1 {","highlight_start":1,"highlight_end":33},{"text":"                    // Identify if thread came from left parent node (1) or right parent node (0)","highlight_start":1,"highlight_end":98},{"text":"                    // Get node number from id","highlight_start":1,"highlight_end":47},{"text":"                    let id = node % 2;","highlight_start":1,"highlight_end":39},{"text":"                    node = node / 2;","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Announce you are competing","highlight_start":1,"highlight_end":50},{"text":"                    competing[node][id] = 1;","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Local variable of if another thread is in same node","highlight_start":1,"highlight_end":75},{"text":"                    let local = (turn[node][1 - id] + id) % 2;","highlight_start":1,"highlight_end":63},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    turn[node][id] = local;","highlight_start":1,"highlight_end":44},{"text":"                    // Cond1 : You are the only thread, and no others are competing in same node","highlight_start":1,"highlight_end":97},{"text":"                    // Cond2 : The other thread is competing, but is outside the critical section","highlight_start":1,"highlight_end":98},{"text":"                    // while not true, wait until you can enter the critical section","highlight_start":1,"highlight_end":85},{"text":"                    while !((competing[node][1 - id] == 0)","highlight_start":1,"highlight_end":59},{"text":"                        || (local != (turn[node][1 - id] + id) % 2))","highlight_start":1,"highlight_end":69},{"text":"                    {}","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    edge[node] = id;","highlight_start":1,"highlight_end":37},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                // Critical section","highlight_start":1,"highlight_end":36},{"text":"                // update global sum","highlight_start":1,"highlight_end":37},{"text":"                totalsum += work(4);","highlight_start":1,"highlight_end":37},{"text":"                // update node so as to stay out of next iteration of big while loop","highlight_start":1,"highlight_end":85},{"text":"                node = 1;","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Begin UP pass through the tournament tree","highlight_start":1,"highlight_end":61},{"text":"                // set flags of other nodes you competed with to false (0) so they may compete as well","highlight_start":1,"highlight_end":103},{"text":"                // propagate values through the arithmetic to climb up the tree","highlight_start":1,"highlight_end":80},{"text":"                while node < n {","highlight_start":1,"highlight_end":33},{"text":"                    competing[node][edge[node]] = 0;","highlight_start":1,"highlight_end":53},{"text":"                    node = 2 * node + edge[node];","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }));","highlight_start":1,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"to force the closure to take ownership of `totalsum` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":906,"byte_end":908,"line_start":32,"line_end":32,"column_start":36,"column_end":38,"is_primary":true,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":36,"highlight_end":38}],"label":null,"suggested_replacement":"move ||","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0373]\u001b[0m\u001b[0m\u001b[1m: closure may outlive the current function, but it borrows `totalsum`, which is owned by the current function\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:32:36\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        threads.push(thread::spawn(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmay outlive borrowed value `totalsum`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m65\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                totalsum += work(4);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`totalsum` is borrowed here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function requires argument type to outlive `'static`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:32:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m        threads.push(thread::spawn(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m______________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Begin downpass through the tournament tree\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Initialize variables local to each threads\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let idThread = i;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m77\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|__________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: to force the closure to take ownership of `totalsum` (and any other referenced variables), use the `move` keyword\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        threads.push(thread::spawn(move || {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^\u001b[0m\n\n"}
{"message":"cannot use `totalsum` because it was mutably borrowed","code":{"code":"E0503","explanation":"A value was used after it was mutably borrowed.\n\nErroneous code example:\n\n```compile_fail,E0503\nfn main() {\n    let mut value = 3;\n    // Create a mutable borrow of `value`.\n    let borrow = &mut value;\n    let _sum = value + 1; // error: cannot use `value` because\n                          //        it was mutably borrowed\n    println!(\"{}\", borrow);\n}\n```\n\nIn this example, `value` is mutably borrowed by `borrow` and cannot be\nused to calculate `sum`. This is not possible because this would violate\nRust's mutability rules.\n\nYou can fix this error by finishing using the borrow before the next use of\nthe value:\n\n```\nfn main() {\n    let mut value = 3;\n    let borrow = &mut value;\n    println!(\"{}\", borrow);\n    // The block has ended and with it the borrow.\n    // You can now use `value` again.\n    let _sum = value + 1;\n}\n```\n\nOr by cloning `value` before borrowing it:\n\n```\nfn main() {\n    let mut value = 3;\n    // We clone `value`, creating a copy.\n    let value_cloned = value.clone();\n    // The mutable borrow is a reference to `value` and\n    // not to `value_cloned`...\n    let borrow = &mut value;\n    // ... which means we can still use `value_cloned`,\n    let _sum = value_cloned + 1;\n    // even though the borrow only ends here.\n    println!(\"{}\", borrow);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":906,"byte_end":908,"line_start":32,"line_end":32,"column_start":36,"column_end":38,"is_primary":false,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":36,"highlight_end":38}],"label":"borrow of `totalsum` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":2995,"byte_end":3003,"line_start":82,"line_end":82,"column_start":5,"column_end":13,"is_primary":true,"text":[{"text":"    totalsum","highlight_start":5,"highlight_end":13}],"label":"use of borrowed `totalsum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":2355,"byte_end":2363,"line_start":65,"line_end":65,"column_start":17,"column_end":25,"is_primary":false,"text":[{"text":"                totalsum += work(4);","highlight_start":17,"highlight_end":25}],"label":"borrow occurs due to use of `totalsum` in closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":892,"byte_end":2910,"line_start":32,"line_end":77,"column_start":22,"column_end":11,"is_primary":false,"text":[{"text":"        threads.push(thread::spawn(|| {","highlight_start":22,"highlight_end":40},{"text":"            // Begin downpass through the tournament tree","highlight_start":1,"highlight_end":58},{"text":"            // Initialize variables local to each threads","highlight_start":1,"highlight_end":58},{"text":"            let idThread = i;","highlight_start":1,"highlight_end":30},{"text":"            let mut node = idThread + n;","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            // Begin local tournaments in each node","highlight_start":1,"highlight_end":52},{"text":"            // When thread reaches node == 1, may enter critical section","highlight_start":1,"highlight_end":73},{"text":"            unsafe {","highlight_start":1,"highlight_end":21},{"text":"                while node > 1 {","highlight_start":1,"highlight_end":33},{"text":"                    // Identify if thread came from left parent node (1) or right parent node (0)","highlight_start":1,"highlight_end":98},{"text":"                    // Get node number from id","highlight_start":1,"highlight_end":47},{"text":"                    let id = node % 2;","highlight_start":1,"highlight_end":39},{"text":"                    node = node / 2;","highlight_start":1,"highlight_end":37},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Announce you are competing","highlight_start":1,"highlight_end":50},{"text":"                    competing[node][id] = 1;","highlight_start":1,"highlight_end":45},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    // Local variable of if another thread is in same node","highlight_start":1,"highlight_end":75},{"text":"                    let local = (turn[node][1 - id] + id) % 2;","highlight_start":1,"highlight_end":63},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    turn[node][id] = local;","highlight_start":1,"highlight_end":44},{"text":"                    // Cond1 : You are the only thread, and no others are competing in same node","highlight_start":1,"highlight_end":97},{"text":"                    // Cond2 : The other thread is competing, but is outside the critical section","highlight_start":1,"highlight_end":98},{"text":"                    // while not true, wait until you can enter the critical section","highlight_start":1,"highlight_end":85},{"text":"                    while !((competing[node][1 - id] == 0)","highlight_start":1,"highlight_end":59},{"text":"                        || (local != (turn[node][1 - id] + id) % 2))","highlight_start":1,"highlight_end":69},{"text":"                    {}","highlight_start":1,"highlight_end":23},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                    edge[node] = id;","highlight_start":1,"highlight_end":37},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                // Critical section","highlight_start":1,"highlight_end":36},{"text":"                // update global sum","highlight_start":1,"highlight_end":37},{"text":"                totalsum += work(4);","highlight_start":1,"highlight_end":37},{"text":"                // update node so as to stay out of next iteration of big while loop","highlight_start":1,"highlight_end":85},{"text":"                node = 1;","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Begin UP pass through the tournament tree","highlight_start":1,"highlight_end":61},{"text":"                // set flags of other nodes you competed with to false (0) so they may compete as well","highlight_start":1,"highlight_end":103},{"text":"                // propagate values through the arithmetic to climb up the tree","highlight_start":1,"highlight_end":80},{"text":"                while node < n {","highlight_start":1,"highlight_end":33},{"text":"                    competing[node][edge[node]] = 0;","highlight_start":1,"highlight_end":53},{"text":"                    node = 2 * node + edge[node];","highlight_start":1,"highlight_end":50},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }));","highlight_start":1,"highlight_end":11}],"label":"argument requires that `totalsum` is borrowed for `'static`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0503]\u001b[0m\u001b[0m\u001b[1m: cannot use `totalsum` because it was mutably borrowed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:82:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m        threads.push(thread::spawn(|| {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mborrow of `totalsum` occurs here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m______________________|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Begin downpass through the tournament tree\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Initialize variables local to each threads\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let idThread = i;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m65\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                totalsum += work(4);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mborrow occurs due to use of `totalsum` in closure\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m77\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|__________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12margument requires that `totalsum` is borrowed for `'static`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m82\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m    totalsum\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of borrowed `totalsum`\u001b[0m\n\n"}
{"message":"unnecessary `unsafe` block","code":{"code":"unused_unsafe","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":1236,"byte_end":1242,"line_start":40,"line_end":40,"column_start":13,"column_end":19,"is_primary":true,"text":[{"text":"            unsafe {","highlight_start":13,"highlight_end":19}],"label":"unnecessary `unsafe` block","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_unsafe)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unnecessary `unsafe` block\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:40:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m40\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            unsafe {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33munnecessary `unsafe` block\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_unsafe)]` on by default\u001b[0m\n\n"}
{"message":"aborting due to 11 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 11 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0373, E0499, E0503.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0373, E0499, E0503.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0373`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0373`.\u001b[0m\n"}
